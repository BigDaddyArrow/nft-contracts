// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import "erc721a-upgradeable/contracts/ERC721AUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";

import "./MembershipNFT.sol";

contract MembershipNFT_ERC721A is MembershipNFT, ERC721AUpgradeable, OwnableUpgradeable, ReentrancyGuardUpgradeable, IERC2981 {

    modifier onlyOwner override(OwnableUpgradeable, MembershipNFT) {
        super.onlyOwner();
        _;
    }

    modifier nonReentrant override(ReentrancyGuardUpgradeable, MembershipNFT) {
        super.nonReentrant();
        _;
    }

    function initialize(
        uint256 _price,
        uint256 _maxSupply,
        uint256 _nReserved,
        uint256 _maxPerMint,
        uint256 _royaltyFee,
        string memory _uri,
        string memory _name,
        string memory _symbol,
        bool _startAtOne
    ) public override initializer {
        super.initialize(
            _price, _maxSupply, _nReserved,
            _maxPerMint, _royaltyFee, _uri,
            _name, _symbol, _startAtOne
        );

        __ReentrancyGuard_init();
        __Ownable_init();
        __ERC721A_init(_name, _symbol);
    }


    // This constructor ensures that this contract can only be used as a master copy
    // Marking constructor as initializer makes sure that real initializer cannot be called
    // Thus, as the owner of the contract is 0x0, no one can do anything with the contract
    // on the other hand, it's impossible to call this function in proxy,
    // so the real initializer is the only initializer
    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() initializer {}


    function startTokenId() public view returns (uint256) {
        return _startTokenId();
    }

    function _mintConsecutive(
        uint256 nTokens,
        address to,
        bytes32 extraData
    ) internal override {
        require(
            _totalMinted() + nTokens + reserved <= maxSupply,
            "Not enough Tokens left."
        );

        uint256 currentTokenIndex = _currentIndex;

        _safeMint(to, nTokens, "");

        if (extraData.length > 0) {
            for (uint256 i; i < nTokens; i++) {
                uint256 tokenId = currentTokenIndex + i;
                data[tokenId] = extraData;
            }
        }
    }

    function tokenURI(uint256 tokenId)
        public
        view
        override
        returns (string memory)
    {
        if (uriExtension != address(0)) {
            string memory uri = INFTURIExtension(uriExtension).tokenURI(
                tokenId
            );

            if (bytes(uri).length > 0) {
                return uri;
            }
        }

        if (bytes(URI_POSTFIX).length > 0) {
            return
                string(abi.encodePacked(super.tokenURI(tokenId), URI_POSTFIX));
        } else {
            return super.tokenURI(tokenId);
        }
    }


}